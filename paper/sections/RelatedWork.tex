\section{Related Work}\label{sec:relatedwork}

\paragraph{Family Polymorphism}

There has been a lot of related work on family polymorphism~\cite{ernst2001family}, including various lightweight encodings~\cite{Kamina:2007:LSC:1289971.1289996,saito2007essence,igarashi2005lightweight,Kamina:2008:LDC:1449913.1449932}. In the original
paper~\cite{ernst2001family}, nested classes are represented as attributes of an object, which involves a dependent type system. In~\cite{igarashi2005lightweight}, Saito and Igarashi
proposed a lightweight variant of family polymorphism, which uses classes rather than objects to represent families. Later work in~\cite{igarashi2005lightweight}
proposes a simple extension to Featherweight Generic Java~\cite{Igarashi:2001:FJM:503502.503505}, introducing self-type variables. There are also some existing languages,
like Scala, which supports symmetric mixin compositions and self-type annotations[?], hence can provide better support for encoding family
polymorphism. Our lightweight encoding relies entirely on the existing Java language without language extensions, and certainly some features from
the original paper are sacrificed, including the mismatching problem of recursive class definitions (also known as binary methods~\cite{bruce1995binary}). Relying
on the Java semantics, covariant return types are supported and used for our automatic type refinements. Nevertheless, in the case of binary methods,
we cannot address those with recursive member types as parameters. This problem is however handled in some other work like MyType[?], ThisType[?] and self-type
annotations in Scala as we said.

On the other hand, our approach uses nested interfaces to build the relationship among families and members, which is different from
path-dependent types in~\cite{ernst2001family}. The work in~\cite{ernst2003higher} inspires us with the concept of higher-order hierarchies, and hence our \textsf{@Family} annotation
provides support for nested families. Furthermore, our lightweight encoding of family polymorphism is polished with the help of annotation processing
to generate constructor methods automatically.

%[1] family polymorphism
%[2] Lightweight scalable components
%[3] The essence of lightweight family polymorphism
%[4] Lightweight family polymorphism
%[5] Lightweight dependent classes
%[6] Featherweight Java
%[7] On binary method
%[8] Higher-order hierarchies

%\paragraph{ThisType}

\paragraph{Multiple Inheritance}

Multiple inheritance is an expressive and useful feature in programming languages, yet difficult to model in relation to the famous diamond problem[?].
Many models have been developed to integrate multiple inheritance in some languages, including C++ virtual inheritance[?], mixins[?], traits[?] and
hybrid models such as CZ[?]. In our approach, introducing new variants or operations requires subtyping relations among member types to be built, and
hence we rely on the Java multiple interface inheritance. A difference from the other models is that our \textsf{@Family} annotation can check method
typing and detect conflicts during the annotation processing, and on the other hand, subtyping relations are automatically generated for the users, which
makes client code more concise. Furthermore, we have mentioned that interfaces are updated with auto-generated constructor methods, whereas object initialization is a big problem in some other models.
